(function(e){function t(t){for(var a,o,i=t[0],c=t[1],u=t[2],b=0,v=[];b<i.length;b++)o=i[b],s[o]&&v.push(s[o][0]),s[o]=0;for(a in c)Object.prototype.hasOwnProperty.call(c,a)&&(e[a]=c[a]);l&&l(t);while(v.length)v.shift()();return r.push.apply(r,u||[]),n()}function n(){for(var e,t=0;t<r.length;t++){for(var n=r[t],a=!0,i=1;i<n.length;i++){var c=n[i];0!==s[c]&&(a=!1)}a&&(r.splice(t--,1),e=o(o.s=n[0]))}return e}var a={},s={app:0},r=[];function o(t){if(a[t])return a[t].exports;var n=a[t]={i:t,l:!1,exports:{}};return e[t].call(n.exports,n,n.exports,o),n.l=!0,n.exports}o.m=e,o.c=a,o.d=function(e,t,n){o.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},o.r=function(e){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},o.t=function(e,t){if(1&t&&(e=o(e)),8&t)return e;if(4&t&&"object"===typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(o.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var a in e)o.d(n,a,function(t){return e[t]}.bind(null,a));return n},o.n=function(e){var t=e&&e.__esModule?function(){return e["default"]}:function(){return e};return o.d(t,"a",t),t},o.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},o.p="/ppt/";var i=window["webpackJsonp"]=window["webpackJsonp"]||[],c=i.push.bind(i);i.push=t,i=i.slice();for(var u=0;u<i.length;u++)t(i[u]);var l=c;r.push([0,"chunk-vendors"]),n()})({0:function(e,t,n){e.exports=n("56d7")},"0dd1":function(e,t,n){"use strict";n.r(t);var a=function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",{attrs:{id:"MyFirstSlideshow"}},[a("div",{staticClass:"eg-slideshow"},[a("slide",{attrs:{enter:"fadeIn",leave:"bounceOutLeft"}},[a("div",{staticClass:"center frontpage"},[a("h1",[e._v("Vue.js")]),a("img",{attrs:{src:n("8128")}}),a("h4",[e._v("Vue.js 响应式原理分析")])]),a("h4",{staticClass:"auther"},[e._v("By Ryan")])]),a("slide",{attrs:{enter:"bounceInRight",leave:"fadeOut"}},[a("h3",[e._v("最终目标"),a("div",{staticClass:"inline animated infinite pulse heart"})]),a("eg-transition",{attrs:{enter:"flipInX"}},[a("eg-code-block",{attrs:{lang:"html"}},[e._v('const demo = new Vue({\n  data: {\n    text: "before",\n  },\n  render(h){ '),a("eg-code-comment",{attrs:{enter:"flipInY"}},[e._v("对应的template 为  <div><span>{ {text} }</span></div>")]),e._v("\n    return h('div', {}, [\n      h('span', {}, [this.__toString__(this.text)])\n    ])\n  }\n})\nsetTimeout(function(){\n  demo.text = \"after\"\n}, 3000)")],1)],1),a("eg-transition",{attrs:{enter:"flipInX"}},[a("p",[e._v("对应的虚拟DOM变化")])]),a("eg-transition",{attrs:{enter:"flipInX"}},[a("eg-code-block",{attrs:{lang:"html"}},[e._v("<div><span>before</span></div> "),a("eg-code-comment",{attrs:{enter:"flipInY"}},[e._v("变化前")]),e._v("\n<--经过3000毫秒后--\x3e\n<div><span>after</span></div> "),a("eg-code-comment",{attrs:{enter:"flipInY"}},[e._v("变化后")])],1)],1)],1),a("slide",{attrs:{steps:3,enter:"bounceInDown"}},[a("h4",[e._v("第一步,监听data下的所有属性")]),a("div",{staticClass:"center"},[a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[e.step>=2?a("p",{staticClass:"first-content"},[a("b",[e._v("1.")]),e._v(" 当data下的某个属性变化时，如何触发相应的函数？")]):e._e()])],1),a("eg-transition",{attrs:{enter:"bounceInRight",leave:"bounceOutRight"}},[e.step>=3?a("p",[a("b",[e._v("方案：")]),e._v(" ES5中新添加了一个方法:Object.defineProperty，通过这个方法，可以自定义 getter 和 setter 函数，那么在获取对象属性或者设置对象属性时就能够执行相应的回调函数")]):e._e()])],1),a("slide",{attrs:{enter:"bounceInDown"}},[a("h4",[e._v("Object.defineProperty 介绍")]),a("div",{staticClass:"center"},[a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[a("img",{attrs:{src:n("3463")}})])],1)]),a("slide",{attrs:{enter:"bounceInRight",leave:"fadeOut"}},[a("div",{staticClass:"vue-code"},[a("eg-transition",{attrs:{enter:"flipInX"}},[a("eg-code-block",{attrs:{lang:"html"}},[e._v("class Vue {\n  constructor(options) {\n    this.$options = options\n    this._data = options.data\n    observer(options.data, this._update.bind(this))\n    this._update()\n  }\n  _update(){\n    this.$options.render()\n  }\n}\nfunction observer(obj, cb) {\n  Object.keys(obj).forEach((key) => {\n    defineReactive(obj, key, obj[key], cb)\n  })\n}\nfunction defineReactive(obj, key, val, cb) {\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: () => {\n      console.log('你访问了' + key)\n      return val\n    },\n    set: newVal => {\n      if (newVal === val)\n        return\n      console.log('你设置了' + key)\n      console.log('新的' + key + ' = ' + newVal)\n      val = newVal\n      cb()\n    }\n  })\n}")])],1)],1),a("div",{staticClass:"vue-obj-code"},[a("eg-transition",{attrs:{enter:"flipInX"}},[a("eg-code-block",{attrs:{lang:"html"}},[e._v('var demo1 = new Vue({\n  el: \'#demo\',\n  data: {\n    text: "before"\n  },\n  render(){\n    console.log("我要render了")\n  }\n})')])],1)],1)]),a("slide",{attrs:{enter:"bounceInDown"}},[a("h4",[e._v("data中的属性是一个对象还能转换为响应式么？")]),a("eg-transition",{attrs:{enter:"flipInX"}},[a("eg-code-block",{attrs:{lang:"html"}},[e._v('var demo2 = new Vue({\n  el: \'#demo\',\n  data: {\n    text: "before",\n    o: {\n      text: "o-before"\n    }\n  },\n  render(){\n    console.log("我要render了")\n  }\n})')])],1)],1),a("slide",{attrs:{enter:"bounceInDown"}},[a("h4",[e._v("用递归解决，将观察者函数(observer)改造")]),a("eg-transition",{attrs:{enter:"flipInX"}},[a("eg-code-block",{attrs:{lang:"html"}},[e._v("function observer(obj, cb)) {\n  Object.keys(obj).forEach((key) => {\n    if (typeof obj[key] === 'object') { "),a("eg-code-comment",{attrs:{enter:"flipInY"}},[e._v("加上判断，进行递归")]),e._v("\n      new observer(obj[key], cb)\n    }\n    defineReactive(obj, key, obj[key], cb))\n  })\n}")],1)],1)],1),a("slide",{attrs:{enter:"bounceInDown"}},[a("h4",[e._v("添加代理，将 demo._data.text 写法转换为 demo.text")]),a("eg-transition",{attrs:{enter:"flipInX"}},[a("eg-code-block",{attrs:{lang:"html"}},[e._v("_proxy(key) {\n  const self = this\n  Object.defineProperty(self, key, {\n    configurable: true,\n    enumerable: true,\n    get: function proxyGetter() {\n      return self._data[key]\n    },\n    set: function proxySetter(val) {\n      self._data[key] = val\n    }\n  })\n}")])],1),a("p",[e._v("构造函数中加上如下代码")]),a("eg-transition",{attrs:{enter:"flipInX"}},[a("eg-code-block",{attrs:{lang:"html"}},[e._v("Object.keys(options.data).forEach(key => this._proxy(key))")])],1)],1),a("slide",{attrs:{steps:5,enter:"bounceInRight",leave:"bounceOutDown"}},[a("h3",[e._v("转换响应式工作完工")]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[e.step>=2?a("p",[a("b",[e._v("1.")]),e._v(" 只要 data 的属性发生变化，就会触发 render 函数")]):e._e()]),a("eg-transition",{attrs:{enter:"bounceInRight",leave:"bounceOutRight"}},[e.step>=3?a("p",[a("b",[e._v("2.")]),e._v(" 这也是为什么只有 data 中的属性是响应式的，而其他地方声明的值不是的原因")]):e._e()]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[e.step>=4?a("p",[e._v("但是这里有个问题 -- ？")]):e._e()]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[e.step>=5?a("p",{staticClass:"center"},[e._v("即触发 render 函数的准确度问题！")]):e._e()])],1),a("slide",{attrs:{steps:3,enter:"bounceInDown"}},[a("h4",[e._v("第二步,解决准确度问题，引出虚拟dom")]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[e.step>=2?a("p",[e._v("思考下边的 demo")]):e._e()]),e.step>=2?a("eg-transition",{attrs:{enter:"flipInX"}},[a("eg-code-block",{attrs:{lang:"html"}},[e._v("new Vue({\n  template: `\n    <div>\n      <span>name:</span> { {name} }\n    <div>`,\n  data: {\n    name: 'js',\n    age: 24\n  }\n})\n\nsetTimeout(function(){\n  demo.age = 25 "),a("eg-code-comment",{attrs:{active:3===e.step,enter:"flipInY"}},[e._v("修改 age 属性，会触发渲染么？")]),e._v("\n}, 3000)")],1)],1):e._e()],1),a("slide",{attrs:{steps:3,enter:"bounceInRight",leave:"bounceOutDown"}},[a("h3",[e._v("简单介绍虚拟 dom")]),a("div",{staticClass:"dom-left"},[a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[e.step>=2?a("p",[e._v("vue有以下两种写法：")]):e._e()]),e.step>=2?a("eg-transition",{attrs:{enter:"flipInX"}},[a("eg-code-block",{attrs:{lang:"html"}},[e._v('// template模板写法（最常用的）\nnew Vue({\n  data: {\n    text: "before",\n  },\n  template: `\n    <div>\n      <span>text:</span> '+e._s(e.text)+'\n    </div>`\n})\n// render函数写法，类似react的jsx写法\nnew Vue({\n  data: {\n    text: "before",\n  },\n  render (h) {\n    return (\n      <div>\n        <span>text:</span> '+e._s(e.text)+"\n      </div>\n    )\n  }\n})")])],1):e._e()],1),a("div",{staticClass:"dom-right"},[a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[e.step>=3?a("p",[e._v("转化为下边格式：")]):e._e()]),e.step>=3?a("eg-transition",{attrs:{enter:"flipInX"}},[a("eg-code-block",{attrs:{lang:"html"}},[e._v("new Vue({\n  data: {\n    text: \"before\",\n  },\n  render(){\n    return this.__h__('div', {}, [\n      this.__h__('span', {}, [this.__toString__(this.text)])\n    ])\n  }\n})")])],1):e._e()],1)]),a("slide",{attrs:{enter:"bounceInDown"}},[a("p",{staticClass:"center"},[e._v("透过上边的 render 函数中的 this.__h__ 方法，可以简单了解下虚拟dom")]),a("eg-transition",{attrs:{enter:"flipInX"}},[a("eg-code-block",{attrs:{lang:"html"}},[e._v("function VNode(tag, data, children, text) {\n  return {\n    tag: tag, // html标签名\n    data: data, // 包含诸如 class 和 style 这些标签上的属性\n    children: children, // 子节点\n    text: text // 文本节点\n  }\n}")])],1)],1),a("slide",{attrs:{enter:"bounceInDown"}},[a("h4",{staticClass:"center dom-demo-title"},[e._v("简单的虚拟dom demo")]),a("div",{staticClass:"dom-demo-code"},[a("eg-transition",{attrs:{enter:"flipInX"}},[a("eg-code-block",{attrs:{lang:"html"}},[e._v("function VNode(tag, data, children, text) {\n  return {\n    tag: tag,\n    data: data,\n    children: children,\n    text: text\n  }\n}\n\nclass Vue {\n  constructor(options) {\n    this.$options = options\n    const vdom = this._update()\n    console.log(vdom)\n  }\n  _update() {\n    return this._render.call(this)\n  }\n  _render() {\n    const vnode = this.$options.render.call(this)\n    return vnode\n  }\n  __h__(tag, attr, children) {\n    return VNode(tag, attr, children.map((child)=>{\n      if(typeof child === 'string'){\n        return VNode(undefined, undefined, undefined, child)\n      }else{\n        return child\n      }\n    }))\n  }\n  __toString__(val) {\n    return val == null ? '' : typeof val === 'object' ? JSON.stringify(val, null, 2) : String(val);\n  }\n}\n\nvar demo = new Vue({\n  el: '#demo',\n  data: {\n    text: \"before\",\n  },\n  render(){\n    return this.__h__('div', {}, [\n      this.__h__('span', {}, [this.__toString__(this.text)])\n    ])\n  }\n})")])],1)],1)]),a("slide",{attrs:{enter:"bounceInDown"}},[a("h4",[e._v("回头看问题")]),a("p",{staticClass:"zongjie"},[e._v("我们需要知道 render 函数中依赖了 data 中的哪些属性，只有这些属性变化，才需要去触发 render 函数")])]),a("slide",{attrs:{steps:3,enter:"bounceInDown"}},[a("h4",[e._v("第三步，依赖收集，准确渲染")]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[e.step>=2?a("p",[a("b",[e._v("思路：")]),e._v(" 在这之前，我们已经把 data 中的属性改成响应式了，当去获取或者修改这些变量时便能够触发相应函数。那这里就可以利用这个相应的函数做些手脚了。")]):e._e()]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[e.step>=2?a("p",[e._v("当声明一个 vue 对象时，在执行 render 函数获取虚拟dom的这个过程中，已经对 render 中依赖的 data 属性进行了一次获取操作，这次获取操作便可以拿到所有依赖。")]):e._e()]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[e.step>=3?a("p",[e._v("其实不仅是 render，任何一个变量的改别，是因为别的变量改变引起(观察者模式)，都可以用上述方法，也就是 computed 和 watch 的原理")]):e._e()])],1),a("slide",{attrs:{enter:"bounceInDown"}},[a("h4",{staticClass:"shouji"},[e._v("依赖收集")]),a("p",{staticClass:"shouji-p"},[e._v("首先需要写一个依赖收集的类，每一个data中的属性都有可能被依赖，因此每个属性在响应式转化(defineReactive)的时候，就初始化它。")]),a("eg-transition",{attrs:{enter:"flipInX"}},[a("eg-code-block",{attrs:{lang:"html"}},[e._v("class Dep {\n  constructor() {\n    this.subs = []\n  }\n  add(cb) {\n    this.subs.push(cb)\n  }\n  notify() {\n    console.log(this.subs)\n    this.subs.forEach((cb) => cb())\n  }\n}\n\nfunction defineReactive(obj, key, val, cb) {\n  const dep = new Dep()\n  Object.defineProperty(obj, key, {\n    // 省略\n  })\n}")])],1)],1),a("slide",{attrs:{steps:5,enter:"bounceInDown"}},[a("h4",[e._v("执行过程")]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[e.step>=2?a("p",[e._v("当执行render函数的时候，依赖到的变量的get就会被执行，然后就把这个 render函数加到subs里面去。")]):e._e()]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[e.step>=3?a("p",[e._v("当set的时候,就执行notify，将所有的subs数组里的函数执行，其中就包含render的执行。")]):e._e()]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[e.step>=4?a("p",[e._v("代码中有一个Dep.target值，这个值时用来区分是普通的get还是收集依赖时的get")]):e._e()]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[e.step>=5?a("p",[a("b",[e._v("完整代码：")]),e._v(" https://github.com/SirM2z/assets/blob/master/vue-demo.js")]):e._e()])],1),a("slide",{attrs:{enter:"bounceInDown"}},[a("h4",[e._v("vue react响应式简单对比")]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[a("p",[a("b",[e._v("综上发现：")]),e._v(" 用Object.defineProperty这个特性可以精确的写出订阅发布模式，从这点来说，vue是优于react的，在没经过优化之前，vue的渲染机制一定是比react更加准确的，为了验证这一说法，我用两个框架同时写了两个相同的简单项目进行对比。")])])],1),a("slide",{attrs:{steps:2,enter:"bounceInDown"}},[a("h4",[e._v("没有对比就没有伤害")]),a("ul",[a("li",[e._v("react项目地址：http://sirm2z.github.io/react-vue-test/react/index.html")]),a("li",[e._v("vue项目地址：http://sirm2z.github.io/react-vue-test/vue/index.html")])]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[e.step>=2?a("p",[e._v("通过对比发现，react 在正常使用的过程中产生了多余的渲染，在移动端或者组件嵌套非常深的情况下会产生非常大的性能消耗，因此在使用 react 的过程中，写好 react 生命周期中的 shouldComponentUpdate 是非常重要的！")]):e._e()])],1),a("slide",{attrs:{enter:"bounceInDown"}},[a("h4",[e._v("所有资源")]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[a("p",[a("ul",[a("li",[a("b",[e._v("完整代码：")]),e._v(" https://github.com/SirM2z/assets/blob/master/vue-demo.js")]),a("li",[a("b",[e._v("PPT网址：")]),e._v(" http://sirm2z.github.io/vue-demo-ppt/index.html")]),a("li",[a("b",[e._v("博客文章网址：")]),e._v(" http://www.jianshu.com/p/7374c4e91891")]),a("li",[a("b",[e._v("react项目地址：")]),e._v(" http://sirm2z.github.io/react-vue-test/react/index.html")]),a("li",[a("b",[e._v("vue项目地址：")]),e._v(" http://sirm2z.github.io/react-vue-test/vue/index.html")])])])])],1),a("slide",{attrs:{enter:"bounceInDown"}},[a("h1",{staticClass:"center end"},[e._v("END")]),a("eg-transition",{attrs:{enter:"flipInX"}},[a("h2",{staticClass:"center"},[e._v("Thanks")])]),a("h4",{staticClass:"auther"},[e._v("By Ryan")])],1)],1)])},s=[],r=n("d973"),o={mixins:[r["b"].slideshow],infos:{title:"Vue.js",description:"Vue.js 响应式原理分析",path:"vue-data-binding"}},i=o,c=(n("f86b"),n("2877")),u=Object(c["a"])(i,a,s,!1,null,null,null);t["default"]=u.exports},"0e9e":function(e,t,n){"use strict";var a=n("9a95"),s=n.n(a);s.a},"0f14":function(e,t,n){e.exports=n.p+"img/promise.22089232.jpg"},"1dec":function(e,t,n){"use strict";var a=n("7065"),s=n.n(a);s.a},2128:function(e,t,n){"use strict";n.r(t);var a=function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",{attrs:{id:"AST"}},[a("div",{staticClass:"eg-slideshow"},[a("slide",{attrs:{enter:"fadeIn",leave:"bounceOutLeft"}},[a("div",{staticClass:"center frontpage"},[a("h1",[e._v("AST")]),a("img",{attrs:{src:n("f3fc")}}),a("h4",[e._v("从AST(抽象语法树)角度看前端")])]),a("h4",{staticClass:"auther"},[e._v("By Ryan")])]),a("slide",{attrs:{enter:"bounceInRight",leave:"fadeOut"}},[a("h4",[e._v("分享主题")]),a("eg-transition",{attrs:{enter:"bounceInRight",leave:"bounceOutLeft"}},[a("p",{staticClass:"first-content center"},[a("b"),e._v("什么是 AST")])]),a("eg-transition",{attrs:{enter:"bounceInRight",leave:"bounceOutLeft"}},[a("p",{staticClass:"center"},[a("b"),e._v("社区中 AST parser 实现")])]),a("eg-transition",{attrs:{enter:"bounceInRight",leave:"bounceOutLeft"}},[a("p",{staticClass:"center"},[a("b"),e._v("Babel 如何通过 AST 读懂 js 代码")])]),a("eg-transition",{attrs:{enter:"bounceInRight",leave:"bounceOutLeft"}},[a("p",{staticClass:"center"},[a("b"),e._v("AST 前端用例")])]),a("eg-transition",{attrs:{enter:"bounceInRight",leave:"bounceOutLeft"}},[a("p",{staticClass:"center"},[a("b"),e._v("热更新小程序代码")])])],1),a("slide",{attrs:{steps:3,enter:"bounceInDown"}},[a("h4",[e._v("前端需要掌握什么 ？")]),a("eg-transition",{attrs:{enter:"bounceInDown",leave:"bounceOutUp"}},[e.step>=2?a("p",[a("b",[e._v("普遍的观点认为")])]):e._e()]),a("eg-transition",{attrs:{enter:"bounceInDown",leave:"bounceOutUp"}},[e.step>=2?a("p",[a("b",[e._v("1.")]),e._v("前端就是打好 HTML、CSS、JS 三大基础，深刻理解语义化标签")]):e._e()]),a("eg-transition",{attrs:{enter:"bounceInDown",leave:"bounceOutUp"}},[e.step>=2?a("p",[a("b",[e._v("2.")]),e._v("了解 N 种不同的布局方式，掌握语言的语法、特性、内置 API")]):e._e()]),a("eg-transition",{attrs:{enter:"bounceInDown",leave:"bounceOutUp"}},[e.step>=2?a("p",[a("b",[e._v("3.")]),e._v("再学习一些主流的前端框架，使用社区成熟的脚手架，即可快速搭建一个前端项目")]):e._e()]),a("eg-transition",{attrs:{enter:"bounceInDown",leave:"bounceOutUp"}},[e.step>=3?a("p",[a("b",[e._v("但是")]),e._v(" 技术推陈出新，版本快速迭代")]):e._e()])],1),a("slide",{attrs:{steps:2,enter:"bounceInDown"}},[a("h4",[e._v("万变不离其宗")]),a("eg-transition",{attrs:{enter:"bounceInDown",leave:"bounceOutUp"}},[a("p",{staticClass:"first-content"},[a("b"),e._v("现在很多前端工具致力于流程自动化、规范化，服务于简洁、优雅、高效的编码，将问题高度抽象化、层次化。")])]),a("eg-transition",{attrs:{enter:"bounceInDown",leave:"bounceOutUp"}},[a("p",[a("b"),e._v("而编译原理，作为一门基础理论学科，除了 JS 语言本身的编译器之外，更成为 Babel、ESLint、Stylus、Flow、Pug、YAML、Vue、React、Marked 等开源前端框架的理论基石之一。")])]),a("eg-transition",{attrs:{enter:"bounceInRight",leave:"bounceOutLeft"}},[e.step>=2?a("p",{staticClass:"center"},[a("b",[e._v("AST(抽象语法树)")])]):e._e()])],1),a("slide",{attrs:{enter:"bounceInDown"}},[a("h4",[e._v("什么是 AST ？")]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[a("p",[a("b",[e._v("维基定义")]),e._v(" 在计算机科学中，抽象语法树（abstract syntax tree或者缩写为AST），或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。")])]),a("div",{staticClass:"center"},[a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[a("img",{attrs:{src:n("c660")}})])],1)],1),a("slide",{attrs:{enter:"bounceInDown"}},[a("h4",[e._v("社区中 AST parser 实现")]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[a("p",{staticClass:"first-content"},[a("b",[e._v("uglifyjs / esprima")]),e._v(" - 早期的两个项目")])]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[a("p",[a("img",{staticClass:"img-logo",attrs:{src:n("50cc")}}),a("b",[e._v("espree")]),e._v(" - 基于esprima，用于eslint")])]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[a("p",[a("img",{staticClass:"img-logo",attrs:{src:n("6c6f")}}),a("b",[e._v("acorn")]),e._v(" - 号称是相对于esprima性能更优，Webpack用到")])]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[a("p",[a("img",{staticClass:"img-logo",attrs:{src:n("40f7")}}),a("b",[e._v("babylon")]),e._v(" - fork的acorn项目,用于babel")])]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[a("p",[a("b",[e._v("babel-eslint")]),e._v(" - babel团队维护的，用于配合使用ESLint")])])],1),a("slide",{attrs:{steps:2,enter:"bounceInDown"}},[a("h4",[e._v("工具中的 AST")]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[a("p",[a("b"),e._v("这些 JavaScript Parser 可以把代码转化为一颗抽象语法树（AST），这颗树定义了代码的结构，通过操纵这颗树，我们可以精准的定位到声明语句、赋值语句、运算语句等等，实现对代码的分析、优化、变更等操作")])]),a("div",{staticClass:"center"},[a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[a("img",{attrs:{src:n("f3fc")}})])],1),a("div",{staticClass:"center"},[a("eg-transition",{attrs:{enter:"bounceInRight",leave:"bounceOutRight"}},[e.step>=2?a("p",[a("b",[e._v("接下来就从 Babel 深入 AST")])]):e._e()])],1)],1),a("slide",{attrs:{steps:4,enter:"bounceInDown"}},[a("h4",[e._v("Babel 如何通过 AST 读懂 js 代码")]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[e.step>=2?a("p",[a("b",[e._v("代码是什么")])]):e._e()]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[e.step>=3?a("p",[a("b"),e._v("去掉高亮，其实就是文本，真正赋予这串文本意义的是 "),a("b",[e._v("编译器")]),e._v(" 和 "),a("b",[e._v("解释器")])]):e._e()]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[e.step>=3?a("p",[a("b"),e._v("而对于 js 这门语言来说 就是 "),a("b",[e._v("JIT")]),e._v(" -- "),a("b",[e._v("「即时编译」")])]):e._e()]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[e.step>=4?a("p",[a("b"),e._v("编译过程中，同样会经过"),a("b",[e._v("分词／词法分析")]),e._v(", "),a("b",[e._v("解析／语法分析")]),e._v(", "),a("b",[e._v("代码生成")]),e._v("三个阶段")]):e._e()]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[e.step>=4?a("p",[a("b",[e._v("生成抽象语法树需要经过两个阶段：")]),e._v("分词(tokenize), 语义分析(parse)")]):e._e()])],1),a("slide",{attrs:{enter:"bounceInDown"}},[a("h4",[e._v("编译过程")]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[a("p",[a("b"),e._v("Babel的编译过程跟绝大多数其他语言的编译器大致同理，分为三个阶段")])]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[a("p",[a("b",[e._v("1. parse")]),e._v(" 使用babylon库将源代码转换为AST")])]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[a("p",[a("b",[e._v("2. transform")]),e._v(" 利用各种插件进行代码转换，如JSX transform将React JSX转换为plain object")])]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[a("p",[a("b",[e._v("3. generate")]),e._v(" 将AST转换成代码")])])],1),a("slide",{attrs:{steps:2,enter:"bounceInDown"}},[a("h4",[e._v("编译过程图")]),a("div",{staticClass:"center first-content"},[a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[a("img",{attrs:{src:n("9ad6")}})])],1),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[e.step>=2?a("p",{staticClass:"center"},[a("b"),e._v("在.babelrc里配置的presets和plugins都是在第2步工作的")]):e._e()])],1),a("slide",{attrs:{steps:4,enter:"bounceInDown"}},[a("h4",[e._v("每一步原理")]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[e.step>=2?a("p",[a("b",[e._v("第1步")]),e._v(" 将源代码 字符串 转换成 抽象语法树")]):e._e()]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[e.step>=3?a("p",[a("b",[e._v("第2步")]),e._v(" 遍历这个对象所描述的抽象语法树，遇到哪里需要做一下改变，就直接在对象上进行操作。比如我把IfStatement给改成WhileStatement就达到了把条件判断改成循环的效果")]):e._e()]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[e.step>=4?a("p",[a("b",[e._v("第3步")]),e._v(" 递归遍历这颗语法树，然后生成相应的代码")]):e._e()])],1),a("slide",{attrs:{enter:"bounceInDown"}},[a("h4",[e._v("第一步(parse 阶段)详解")]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[a("p",{staticClass:"first-content"},[a("b"),e._v("生成抽象语法树需要经过两个阶段：")])]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[a("p",[a("b",[e._v("1. 分词(tokenize)")]),e._v(" 将整个代码字符串分割成 语法单元 数组")])]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[a("p",[a("b",[e._v("2. 语义分析(parse)")]),e._v(" 在分词结果的基础之上分析 语法单元之间的关系")])])],1),a("slide",{attrs:{steps:3,enter:"bounceInDown"}},[a("h4",[e._v("分词(tokenize)")]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[a("p",[a("b"),e._v("什么是语法单元？")])]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[a("p",[a("b"),e._v("被解析语法当中具备实际意义的最小单元，通俗点说就是类似于自然语言中的词语")])]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[e.step>=2?a("p",[a("b",[e._v("明天将下雨")]),e._v(" 不管词性及主谓关系等，拆分情况如何？")]):e._e()]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[e.step>=3?a("p",[a("b",[e._v("明天")]),e._v("、"),a("b",[e._v("将")]),e._v("、"),a("b",[e._v("下雨")])]):e._e()]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[e.step>=3?a("p",[a("b"),e._v("这就是分词：把整句话拆分成有意义的最小颗粒，这些小块不能再被拆分，否则就失去它所能表达的意义了")]):e._e()])],1),a("slide",{attrs:{enter:"bounceInRight",leave:"fadeOut"}},[a("h3",[e._v("回到代码解析中")]),a("div",{staticClass:"vue-code three"},[a("eg-transition",{attrs:{enter:"flipInX"}},[a("eg-code-block",{attrs:{lang:"html"}},[e._v('if (1 > 0) {\n  alert("if \\"1 > 0\\"");\n}')])],1)],1),a("div",{staticClass:"vue-obj-code four"},[a("eg-transition",{attrs:{enter:"flipInX"}},[a("eg-code-block",{attrs:{lang:"html"}},[e._v('// 分词结果\n// 这个过程没有取巧，就是一个一个字符读取，并配合大量的 if else 判断\n[\n  { type: "whitespace", value: "\\n" },\n  { type: "identifier", value: "if" },\n  { type: "whitespace", value: " " },\n  { type: "parens", value: "(" },\n  { type: "number", value: "1" },\n  { type: "whitespace", value: " " },\n  { type: "operator", value: ">" },\n  { type: "whitespace", value: " " },\n  { type: "number", value: "0" },\n  { type: "parens", value: ")" },\n  { type: "whitespace", value: " " },\n  { type: "brace", value: "{" },\n  { type: "whitespace", value: "\\n " },\n  { type: "identifier", value: "alert" },\n  { type: "parens", value: "(" },\n  { type: "string", value: "\\"if 1 > 0\\"" },\n  { type: "parens", value: ")" },\n  { type: "sep", value: ";" },\n  { type: "whitespace", value: "\\n" },\n  { type: "brace", value: "}" },\n  { type: "whitespace", value: "\\n" },\n]')])],1)],1)]),a("slide",{attrs:{enter:"bounceInDown"}},[a("h4",[e._v("语义分析(parse)")]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[a("p",{staticClass:"first-content"},[a("b"),e._v("把词汇进行立体的组合，确定有多重意义的词语最终是什么意思、多个词语之间有什么关系以及应该再哪里断句等")])]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[a("p",[a("b"),e._v("语义分析的过程又是个遍历语法单元的过程，不过相比较而言更复杂，因为分词过程中，每个语法单元都是独立平铺的，而语法分析中，语句和表达式会以树状的结构互相包含")])]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[a("p",[a("b"),e._v("针对这种情况我们可以用栈，也可以用递归来实现")])]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[a("p",[a("b"),e._v("看语义分析结果：https://astexplorer.net/")])])],1),a("slide",{attrs:{enter:"bounceInRight",leave:"fadeOut"}},[a("h3",[e._v("AST 用例"),a("div",{staticClass:"inline animated infinite pulse heart"})]),a("eg-transition",{attrs:{enter:"bounceInRight",leave:"bounceOutLeft"}},[a("p",{staticClass:"first-content center"},[a("b"),e._v("AST in UglifyJS")])]),a("eg-transition",{attrs:{enter:"bounceInRight",leave:"bounceOutLeft"}},[a("p",{staticClass:"center"},[a("b"),e._v("AST in ESLint")])]),a("eg-transition",{attrs:{enter:"bounceInRight",leave:"bounceOutLeft"}},[a("p",{staticClass:"center"},[a("b"),e._v("AST in Babel")])]),a("eg-transition",{attrs:{enter:"bounceInRight",leave:"bounceOutLeft"}},[a("p",{staticClass:"center"},[a("b"),e._v("AST in Webpack")])]),a("eg-transition",{attrs:{enter:"bounceInRight",leave:"bounceOutLeft"}},[a("p",{staticClass:"center"},[a("b"),e._v("AST in css")])]),a("eg-transition",{attrs:{enter:"bounceInRight",leave:"bounceOutLeft"}},[a("p",{staticClass:"center"},[a("b"),e._v("解析小程序包/react 的 jsx 语法/虚拟 dom")])])],1),a("slide",{attrs:{enter:"bounceInDown"}},[a("h4",[e._v("AST in UglifyJS")]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[a("p",[a("b"),e._v("UglifyJs 是一个js 解释器、混淆器、压缩器、美化器工具集")])]),a("eg-transition",{attrs:{enter:"flipInX"}},[a("p",[e._v("修改代码中的数字 为 16进制代码：")])]),a("eg-transition",{attrs:{enter:"flipInX"}},[a("eg-code-block",{attrs:{lang:"html"}},[e._v('var UglifyJS = require("uglify-js");\n\nvar code = "var a = 1;";\nvar toplevel = UglifyJS.parse(code); '),a("eg-code-comment",{attrs:{enter:"flipInY"}},[e._v("toplevel就是语法树")]),e._v("\nvar transformer = new UglifyJS.TreeTransformer(function (node) {\n\nif (node instanceof UglifyJS.AST_Number) { "),a("eg-code-comment",{attrs:{enter:"flipInY"}},[e._v("查找需要修改的叶子节点")]),e._v("\n        node.value = '0x' + Number(node.value).toString(16);\n        return node; "),a("eg-code-comment",{attrs:{enter:"flipInY"}},[e._v("返回一个新的叶子节点 替换原来的叶子节点")]),e._v("\n    };\n});\n\ntoplevel.transform(transformer);  "),a("eg-code-comment",{attrs:{enter:"flipInY"}},[e._v("遍历AST树")]),e._v("\nvar ncode = toplevel.print_to_string(); "),a("eg-code-comment",{attrs:{enter:"flipInY"}},[e._v("从AST还原成字符串")]),e._v("\n\nconsole.log(ncode); "),a("eg-code-comment",{attrs:{enter:"flipInY"}},[e._v("var a = 0x1;")])],1)],1)],1),a("slide",{attrs:{enter:"bounceInDown"}},[a("h4",[e._v("全部 16 进制混淆过的代码")]),a("div",{staticClass:"center"},[a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[a("img",{attrs:{src:n("808e")}})])],1)]),a("slide",{attrs:{steps:2,enter:"bounceInDown"}},[a("h4",[e._v("AST in ESLint")]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[a("p",[a("b"),e._v("ESLint的检查基于AST，除了通过配置规则来规范代码，还提供了API，使得我们可以利用源代码生成的AST，开发自定义插件和自定义规则")])]),a("eg-transition",{attrs:{enter:"flipInX"}},[a("eg-code-block",{attrs:{lang:"html"}},[e._v('// 要求赋值语句中，变量名长度大于两位\nmodule.exports = {\n    rules: {\n        "var-length": {\n            create: function (context) {\n                return {\n                    // 关注的语法单元类型\n                    VariableDeclarator: node => { '),a("eg-code-comment",{attrs:{enter:"flipInY"}},[e._v("开发插件时是不可能记住这么多语法单元类型的")]),e._v("\n                        if (node.id.name.length < 2) {\n                            context.report(node, 'Variable names should be longer than 1 character');\n                        }\n                    }\n                };\n            }\n        }\n    }\n};")],1)],1),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[e.step>=2?a("p",[a("b"),e._v("https://astexplorer.net/")]):e._e()])],1),a("slide",{attrs:{enter:"bounceInDown"}},[a("h4",[e._v("AST in Babel")]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[a("p",[a("b"),e._v("Babel是为使用下一代JavaScript语法特性来开发而存在的编译工具，最初这个项目名为6to5，意为将ES6语法转换为ES5")])]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[a("p",[a("b"),e._v("发展到现在，Babel已经形成了一个强大的生态")])])],1),a("slide",{attrs:{enter:"bounceInDown"}},[a("h4",[e._v("Babel提供的 API 可以对代码进行AST转换并且进行各种操作")]),a("eg-transition",{attrs:{enter:"flipInX"}},[a("eg-code-block",{attrs:{lang:"html"}},[e._v('import * as babylon from "babylon";\nimport traverse from "babel-traverse";\nimport generate from "babel-generator";\n\nconst code = `function square(n) {\n    return n * n;\n}`\n\nconst ast = babylon.parse(code);'),a("eg-code-comment",{attrs:{enter:"flipInY"}},[e._v("将源代码字符串 转换为 AST 树")]),e._v("\ntraverse(ast,{"),a("eg-code-comment",{attrs:{enter:"flipInY"}},[e._v("遍历 AST 树")]),e._v("\n    enter(path){\n        if(path.node.type === 'Identifier' && path.node.name === 'n'){\n            path.node.name = 'x'\n        }\n    }\n})\ngenerate(ast,{},code)"),a("eg-code-comment",{attrs:{enter:"flipInY"}},[e._v("还原 AST 树为 代码")])],1)],1)],1),a("slide",{attrs:{enter:"bounceInDown"}},[a("h4",[e._v("AST in Webpack")]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[a("p",{staticClass:"first-content"},[a("b"),e._v("Webpack在打包流程中也需要AST的支持，它借助acorn库解析源码，生成AST，提取模块依赖关系")])]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[a("p",{staticClass:"first-content"},[a("b"),e._v("由Rollup提出，Webpack目前也提供支持的一个特性是treeshaking，去除没有引用的模块")])])],1),a("slide",{attrs:{enter:"bounceInRight",leave:"fadeOut"}},[a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[a("p",[a("b"),e._v("两份代码")])]),a("div",{staticClass:"vue-code"},[a("eg-transition",{attrs:{enter:"flipInX"}},[a("eg-code-block",{attrs:{lang:"html"}},[e._v("//math.js\nexport {doMath, sayMath}\n\nconst add = (a, b) => a + b\nconst subtract = (a, b) => a - b\nconst divide = (a, b) => a / b\nconst multiply = (a, b) => a * b\n\nfunction doMath(a, b, operation) {\n  switch (operation) {\n    case 'add':\n      return add(a, b)\n    case 'subtract':\n      return subtract(a, b)\n    case 'divide':\n      return divide(a, b)\n    case 'multiply':\n      return multiply(a, b)\n    default:\n      throw new Error(`Unsupported operation: ${operation}`)\n  }\n}\n\nfunction sayMath() {\n  return 'MATH!'\n}")])],1)],1),a("div",{staticClass:"vue-obj-code"},[a("eg-transition",{attrs:{enter:"flipInX"}},[a("eg-code-block",{attrs:{lang:"html"}},[e._v("//main.js\nimport {doMath}\ndoMath(2, 3, 'multiply') // 6")])],1)],1)],1),a("slide",{attrs:{enter:"bounceInDown"}},[a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[a("p",[a("b"),e._v("经过 treeshaking 特性 处理过后")])]),a("div",{staticClass:"vue-code one"},[a("eg-transition",{attrs:{enter:"flipInX"}},[a("eg-code-block",{attrs:{lang:"html"}},[e._v("//math.js\nexport {doMath, sayMath}\n\nconst add = (a, b) => a + b\nconst subtract = (a, b) => a - b\nconst divide = (a, b) => a / b\nconst multiply = (a, b) => a * b\n\nfunction doMath(a, b, operation) {\n  switch (operation) {\n    case 'add':\n      return add(a, b)\n    case 'subtract':\n      return subtract(a, b)\n    case 'divide':\n      return divide(a, b)\n    case 'multiply':\n      return multiply(a, b)\n    default:\n      throw new Error(`Unsupported operation: ${operation}`)\n  }\n}\n\nfunction sayMath() {\n  return 'MATH!'\n}")])],1)],1),a("div",{staticClass:"vue-obj-code two"},[a("eg-transition",{attrs:{enter:"flipInX"}},[a("eg-code-block",{attrs:{lang:"html"}},[e._v("//math.js\nexport {doMath}\n\nconst add = (a, b) => a + b\nconst subtract = (a, b) => a - b\nconst divide = (a, b) => a / b\nconst multiply = (a, b) => a * b\n\nfunction doMath(a, b, operation) {\n  switch (operation) {\n    case 'add':\n      return add(a, b)\n    case 'subtract':\n      return subtract(a, b)\n    case 'divide':\n      return divide(a, b)\n    case 'multiply':\n      return multiply(a, b)\n    default:\n      throw new Error(`Unsupported operation: ${operation}`)\n  }\n}")])],1)],1)],1),a("slide",{attrs:{enter:"bounceInDown"}},[a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[a("p",[a("b"),e._v("基于AST，进行更为完善的代码覆盖率分析，应当可以实现这样的效果")])]),a("div",{staticClass:"vue-code"},[a("eg-transition",{attrs:{enter:"flipInX"}},[a("eg-code-block",{attrs:{lang:"html"}},[e._v("//math.js\nexport {doMath, sayMath}\n\nconst add = (a, b) => a + b\nconst subtract = (a, b) => a - b\nconst divide = (a, b) => a / b\nconst multiply = (a, b) => a * b\n\nfunction doMath(a, b, operation) {\n  switch (operation) {\n    case 'add':\n      return add(a, b)\n    case 'subtract':\n      return subtract(a, b)\n    case 'divide':\n      return divide(a, b)\n    case 'multiply':\n      return multiply(a, b)\n    default:\n      throw new Error(`Unsupported operation: ${operation}`)\n  }\n}\n\nfunction sayMath() {\n  return 'MATH!'\n}")])],1)],1),a("div",{staticClass:"vue-obj-code"},[a("eg-transition",{attrs:{enter:"flipInX"}},[a("eg-code-block",{attrs:{lang:"html"}},[e._v("//math.js\nexport {doMath}\n\nconst multiply = (a, b) => a * b\n\nfunction doMath(a, b, operation) {\n  return multiply(a, b)\n}")])],1)],1)],1),a("slide",{attrs:{steps:2,enter:"bounceInDown"}},[a("h4",{staticClass:"center"},[e._v("配置工程师")]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[e.step>=2?a("p",{staticClass:"center first-content"},[a("b"),e._v("其实可以认为我们是在玩 "),a("b",[e._v("编译器")]),e._v("，瞬间就高大上了")]):e._e()])],1),a("slide",{attrs:{steps:2,enter:"bounceInDown"}},[a("h4",[e._v("AST in css")]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[a("p",{staticClass:"first-content"},[a("b"),e._v("PostCSS 提供了一个解析器，它能够将 CSS 解析成抽象语法树（AST）")])]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[e.step>=2?a("p",{staticClass:"first-content center"},[a("b"),e._v("自动补充css前缀插件：autoprefixer")]):e._e()])],1),a("slide",{attrs:{enter:"bounceInDown"}},[a("h3",[e._v("热更新小程序代码")]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[a("p",{staticClass:"first-content"},[a("b",[e._v("原理")])])]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[a("p",[a("b"),e._v("解析 JavaScript 代码字符串，得到 JavaScript 代码的抽象语法树（AST）。解析可以通过开源库，比如 acornjs/acorn 。结果会解析成标准的 ESTree")])]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[a("p",[a("b"),e._v("JavaScript 的语法树是有标准格式的 estree/estree ，所以只需要对照这个标准格式进行实现语法树的求值，只要保证 JavaScript 一样的语义，就和 eval / new Function 等效果差不多了")])])],1),a("slide",{attrs:{enter:"bounceInDown"}},[a("div",{staticClass:"center"},[a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[a("img",{attrs:{src:n("b696")}})])],1)]),a("slide",{attrs:{enter:"bounceInDown"}},[a("h1",{staticClass:"center end"},[e._v("END")]),a("eg-transition",{attrs:{enter:"flipInX"}},[a("h2",{staticClass:"center"},[e._v("Thanks")])]),a("h4",{staticClass:"auther"},[e._v("By Ryan")])],1)],1)])},s=[],r=n("d973"),o={mixins:[r["b"].slideshow],infos:{title:"AST",description:"从AST(抽象语法树)角度看前端",path:"AST"}},i=o,c=(n("1dec"),n("2877")),u=Object(c["a"])(i,a,s,!1,null,null,null);t["default"]=u.exports},2892:function(e,t,n){},3463:function(e,t,n){e.exports=n.p+"img/object_defineProperty_mdn.f95c688b.png"},"40f7":function(e,t,n){e.exports=n.p+"img/babel_logo.658fb855.png"},"4d8e":function(e,t,n){"use strict";n.r(t);var a=function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",{attrs:{id:"Promise"}},[a("div",{staticClass:"eg-slideshow"},[a("slide",{attrs:{enter:"fadeIn",leave:"bounceOutLeft"}},[a("div",{staticClass:"center frontpage"},[a("h1",[e._v("Promise")]),a("img",{attrs:{src:n("0f14")}}),a("h4",[e._v("实现符合 Promises/A+ 规范的 Promise 库")])]),a("h4",{staticClass:"auther"},[e._v("By Ryan")])]),a("slide",{attrs:{enter:"bounceInRight",leave:"fadeOut"}},[a("h4",[e._v("分享主题")]),a("eg-transition",{attrs:{enter:"bounceInRight",leave:"bounceOutLeft"}},[a("p",{staticClass:"first-content center"},[a("b"),e._v("什么是 Promise，为什么引入 Promise")])]),a("eg-transition",{attrs:{enter:"bounceInRight",leave:"bounceOutLeft"}},[a("p",{staticClass:"center"},[a("b"),e._v("Promises/A+ 规范")])]),a("eg-transition",{attrs:{enter:"bounceInRight",leave:"bounceOutLeft"}},[a("p",{staticClass:"center"},[a("b"),e._v("* 手撕 Promise")])]),a("eg-transition",{attrs:{enter:"bounceInRight",leave:"bounceOutLeft"}},[a("p",{staticClass:"center"},[a("b"),e._v("Promises/A+ 测试")])])],1),a("slide",{attrs:{steps:3,enter:"bounceInDown"}},[a("h4",[e._v("什么是 Promise，为什么引入 Promise ？")]),a("eg-transition",{attrs:{enter:"bounceInDown",leave:"bounceOutUp"}},[e.step>=2?a("p",{staticClass:"first-content"},[e._v("Promise 是抽象异步处理对象以及对其进行各种操作的组件")]):e._e()]),a("eg-transition",{attrs:{enter:"bounceInDown",leave:"bounceOutUp"}},[e.step>=2?a("p",[e._v("Promise 并不是从 JavaScript 中发祥的概念")]):e._e()]),a("eg-transition",{attrs:{enter:"bounceInDown",leave:"bounceOutUp"}},[e.step>=3?a("p",[e._v("解决回掉地狱问题")]):e._e()])],1),a("slide",{attrs:{enter:"bounceInDown"}},[a("h4",[e._v("Promises/A+ 规范")]),a("eg-transition",{attrs:{enter:"bounceInDown",leave:"bounceOutUp"}},[a("p",{staticClass:"first-content"},[e._v("An open standard for sound, interoperable JavaScript promises—by implementers, for implementers.")])]),a("eg-transition",{attrs:{enter:"bounceInDown",leave:"bounceOutUp"}},[a("p",{staticClass:"left"},[a("a",{attrs:{href:"https://promisesaplus.com/",target:"_blank"}},[e._v("https://promisesaplus.com/")])])]),a("eg-transition",{attrs:{enter:"bounceInDown",leave:"bounceOutUp"}},[a("p",{staticClass:"left"},[a("a",{attrs:{href:"https://wiki.ryanc.top/translation/promisesaplus.html",target:"_blank"}},[e._v("译文")])])])],1),a("slide",{attrs:{enter:"bounceInDown"}},[a("h3",{staticClass:"center"},[e._v("手撕 Promise")]),a("eg-transition",{attrs:{enter:"bounceInRight",leave:"bounceOutLeft"}},[a("p",{staticClass:"left"},[a("b",[e._v("1.")]),e._v("Promises 骨架")])]),a("eg-transition",{attrs:{enter:"bounceInRight",leave:"bounceOutLeft"}},[a("p",{staticClass:"left"},[a("b",[e._v("2.")]),e._v("executor 错误收集")])]),a("eg-transition",{attrs:{enter:"bounceInRight",leave:"bounceOutLeft"}},[a("p",{staticClass:"left"},[a("b",[e._v("3.")]),e._v("同步/异步 executor （判断逻辑在 then 中）")])]),a("eg-transition",{attrs:{enter:"bounceInRight",leave:"bounceOutLeft"}},[a("p",{staticClass:"left"},[a("b",[e._v("4.")]),e._v("异步 resolve reject 的问题 （转移状态判断）")])]),a("eg-transition",{attrs:{enter:"bounceInRight",leave:"bounceOutLeft"}},[a("p",{staticClass:"left"},[a("b",[e._v("5.")]),e._v("then 链 同步/异步调用")])])],1),a("slide",{attrs:{steps:2,enter:"bounceInDown"}},[a("h4",[e._v("Promises/A+ 测试")]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[a("p",{staticClass:"first-content"},[a("a",{attrs:{href:"https://github.com/promises-aplus/promises-tests#readme",target:"_blank"}},[e._v("promises-aplus-tests")])])]),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[e.step>=2?a("p",{staticClass:"left"},[e._v("在 Promise 实现中加入下方代码")]):e._e()]),a("eg-transition",{attrs:{enter:"flipInX"}},[e.step>=2?a("eg-code-block",{attrs:{lang:"html"}},[e._v("Promise.defer = Promise.deferred = function () {\n  let dfd = {};\n  dfd.promise = new Promise((resolve, reject) => {\n      dfd.resolve = resolve;\n      dfd.reject = reject;\n  });\n  return dfd;\n}")]):e._e()],1),a("eg-transition",{attrs:{enter:"bounceInLeft",leave:"bounceOutLeft"}},[e.step>=2?a("p",{staticClass:"left"},[e._v("在 package.json 中加入下方 script")]):e._e()]),a("eg-transition",{attrs:{enter:"flipInX"}},[e.step>=2?a("eg-code-block",{attrs:{lang:"html"}},[e._v('"test": "promises-aplus-tests ./promise.js"\n')]):e._e()],1)],1),a("slide",{attrs:{enter:"bounceInDown"}},[a("h1",{staticClass:"center end"},[e._v("END")]),a("eg-transition",{attrs:{enter:"flipInX"}},[a("h2",{staticClass:"center"},[e._v("Thanks")])]),a("h4",{staticClass:"auther"},[e._v("By Ryan")])],1)],1)])},s=[],r=n("d973"),o={mixins:[r["b"].slideshow],infos:{title:"Promise",description:"实现符合 Promises/A+ 规范的 Promise 库",path:"promiseaplus"}},i=o,c=(n("0e9e"),n("2877")),u=Object(c["a"])(i,a,s,!1,null,null,null);t["default"]=u.exports},"50cc":function(e,t,n){e.exports=n.p+"img/eslint_logo.5b39f0f7.png"},"56d7":function(e,t,n){"use strict";n.r(t);n("ac6a"),n("cadf"),n("551c"),n("f751"),n("097d");var a=n("2b0e"),s=n("8c4f"),r=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{attrs:{id:"app"}},[n("router-view")],1)},o=[],i={name:"app"},c=i,u=(n("5c0b"),n("2877")),l=Object(u["a"])(c,r,o,!1,null,null,null),b=l.exports,v=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"frontpage"},[n("div",{staticClass:"content"},[e._m(0),n("h2",[e._v("A slideshow framework for hackers")]),n("iframe",{staticClass:"github-star",attrs:{src:"https://ghbtns.com/github-btn.html?user=zulko&repo=eagle.js&type=star&count=true&size=large",frameborder:"0",scrolling:"0",width:"160px",height:"30px"}}),n("p",[e._v("Eagle.js is a web-based slideshow framework for Vue.js.\nIt supports animations, themes, interactive widgets (for web demos),\nand makes it easy to reuse components, slides and styles across presentations.\n")]),n("p",[e._v("Most of all, Eagle aims at offering a simple and very hackable API so you\ncan get off the beaten tracks and craft the slideshows you really want.\n")]),n("div",{staticClass:"thumbnails"},e._l(e.slideshows,function(t){return n("div",{staticClass:"box-card"},[n("router-link",{attrs:{to:t.infos.path},nativeOn:{click:function(t){return e.click(t)}}},[n("div",{staticClass:"embedded-slideshow-container"},[n(t,{tag:"component",attrs:{embedded:!0,keyboardNavigation:!1,mouseNavigation:!1}})],1)]),n("div",{staticClass:"caption"},[n("h3",[e._v(e._s(t.infos.title))]),n("p",{staticClass:"thumbnail-description"},[e._v(e._s(t.infos.description))])])],1)}),0)])])},p=[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("h1",[n("span",{staticClass:"logo"}),n("span",[e._v("Eagle")]),n("span",{staticClass:"grey"},[e._v(".js")])])}],d={list:[n("0dd1").default,n("2128").default,n("4d8e").default]},f={data:function(){return{slideshows:d.list}},mounted:function(){document.currentSlide={}},methods:{click:function(e){e.stopPropagation()}}},_=f,g=(n("af03"),Object(u["a"])(_,v,p,!1,null,"8d13acee",null)),h=g.exports,m=n("d973"),I=(n("b159"),n("1487")),L=n.n(I);a["a"].use(m["b"]),a["a"].use(s["a"]),a["a"].config.productionTip=!1,m["a"].hljs=L.a;var O=[];d.list.forEach(function(e){O.push({path:"/"+e.infos.path,component:e})}),O.push({path:"*",component:h});var y=new s["a"]({routes:O});new a["a"]({el:"#app",router:y,render:function(e){return e("App")},components:{App:b}})},"59db":function(e,t,n){},"5c0b":function(e,t,n){"use strict";var a=n("5e27"),s=n.n(a);s.a},"5e27":function(e,t,n){},"6c6f":function(e,t,n){e.exports=n.p+"img/webpack_logo.0c34d09b.png"},7065:function(e,t,n){},"808e":function(e,t,n){e.exports=n.p+"img/ug.7cc3e872.png"},8128:function(e,t,n){e.exports=n.p+"img/logo.82b9c7a5.png"},"9a95":function(e,t,n){},"9ad6":function(e,t,n){e.exports=n.p+"img/ast2.536c492c.png"},af03:function(e,t,n){"use strict";var a=n("2892"),s=n.n(a);s.a},b696:function(e,t,n){e.exports=n.p+"img/re.d6ad379a.gif"},c660:function(e,t,n){e.exports=n.p+"img/ast1.08b1f546.png"},f3fc:function(e,t,n){e.exports=n.p+"img/ast.42267193.png"},f86b:function(e,t,n){"use strict";var a=n("59db"),s=n.n(a);s.a}});
//# sourceMappingURL=app.cc340a83.js.map